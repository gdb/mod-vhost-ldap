\subsection{ctypes reference\label{ctypes-reference}}

% functions
\subsubsection{ctypes functions}

\begin{funcdesc}{addressof}{obj}
Returns the address of the memory buffer as integer.  \var{obj} must
be an instance of a ctypes type.
\end{funcdesc}

\begin{funcdesc}{alignment}{obj_or_type}
Returns the alignment requirements of a ctypes type.
\var{obj_or_type} must be a ctypes type or an instance.
\end{funcdesc}

\begin{excclassdesc}{ArgumentError}{}
\end{excclassdesc}

\begin{funcdesc}{byref}{obj}
Returns a light-weight pointer to \var{obj}, which must be an instance
of a ctypes type.  The returned object can only be used as a foreign
function call parameter.  It behaves similar to \code{pointer(obj)},
but the construction is a lot faster.
\end{funcdesc}

\begin{funcdesc}{cast}{obj, type}
\end{funcdesc}

\begin{funcdesc}{CFUNCTYPE}{restype, *argtypes}
\end{funcdesc}

\begin{funcdesc}{create_string_buffer}{init_or_size\optional{, size}}
This function creates a mutable character buffer.  The returned object
is a ctypes array of \code{c_char}.

\var{init_or_size} must be an integer which specifies the size of the
array, or a string which will be used to initialize the array items.

If a string is specified as first argument, the buffer is made one
item larger than the length of the string so that the last element in
the array is a NUL termination character.  An integer can be passed as
second argument which allows to specify the size of the array if the
length of the string should not be used.

If the first parameter is a unicode string, it is converted into an
8-bit string according to ctypes conversion rules.
\end{funcdesc}

\begin{funcdesc}{create_unicode_buffer}{init_or_size\optional{, size}}
This function creates a mutable unicode character buffer.  The
returned object is a ctypes array of \code{c_wchar}.

\var{init_or_size} must be an integer which specifies the size of the
array, or a unicode string which will be used to initialize the array
items.

If a unicode string is specified as first argument, the buffer is made
one item larger than the length of the string so that the last element
in the array is a NUL termination character.  An integer can be passed
as second argument which allows to specify the size of the array if
the length of the string should not be used.

If the first parameter is a 8-bit string, it is converted into an
unicode string according to ctypes conversion rules.
\end{funcdesc}

\begin{funcdesc}{DllCanUnloadNow}{}
Windows only: This function is a hook which allows to implement
inprocess COM servers with ctypes.  It is called from the
\code{DllCanUnloadNow} exported function that the \code{_ctypes}
extension module exports.
\end{funcdesc}

\begin{funcdesc}{DllGetClassObject}{}
Windows only: This function is a hook which allows to implement
inprocess COM servers with ctypes.  It is called from the
\code{DllGetClassObject} exported function that the \code{_ctypes}
extension module exports.
\end{funcdesc}

\begin{funcdesc}{FormatError}{}
Windows only:
\end{funcdesc}

\begin{funcdesc}{GetLastError}{}
Windows only:
\end{funcdesc}

\begin{funcdesc}{memmove}{dst, src, count}
\end{funcdesc}

\begin{funcdesc}{memset}{dst, c, count}
\end{funcdesc}

\begin{funcdesc}{POINTER}{}
\end{funcdesc}

\begin{funcdesc}{pointer}{}
\end{funcdesc}

\begin{funcdesc}{PYFUNCTYPE}{restype, *argtypes}
\end{funcdesc}

\begin{funcdesc}{pythonapi}{}
\end{funcdesc}

\begin{funcdesc}{resize}{}
\end{funcdesc}

\begin{funcdesc}{set_conversion_mode}{}
\end{funcdesc}

\begin{funcdesc}{sizeof}{}
\end{funcdesc}

\begin{funcdesc}{string_at}{address}
\end{funcdesc}

\begin{funcdesc}{WinError}{}
\end{funcdesc}

\begin{funcdesc}{WINFUNCTYPE}{restype, *argtypes}
\end{funcdesc}

\begin{funcdesc}{wstring_at}{address}
\end{funcdesc}

% data types
\subsubsection{data types}

ctypes defines a lot of C compatible datatypes, and also allows to
define your own types.  Among other things, a ctypes type instance
holds a memory block that contains C compatible data.

% simple data types
\subsubsection{simple data types}

\begin{classdesc}{c_byte}{\optional{value}}
Represents a C \code{signed char} datatype, and interprets the value
as small integer.  The constructor accepts an optional integer
initializer; no overflow checking is done.
\end{classdesc}

\begin{classdesc}{c_char}{\optional{value}}
Represents a C \code{char} datatype, and interprets the value as a
single character.  The constructor accepts an optional string
initializer, the length of the string must be exactly one character.
\end{classdesc}

\begin{classdesc}{c_char_p}{\optional{value}}
\end{classdesc}

\begin{classdesc}{c_double}{\optional{value}}
Represents a C \code{double} datatype.  The constructor accepts an
optional float initializer.
\end{classdesc}

\begin{classdesc}{c_float}{\optional{value}}
Represents a C \code{double} datatype.  The constructor accepts an
optional float initializer.
\end{classdesc}

\begin{classdesc}{c_int}{\optional{value}}
Represents a C \code{signed int} datatype.  The constructor accepts an
optional integer initializer; no overflow checking is done.  On
platforms where \code{sizeof(int) == sizeof(long)} \var{c_int} is an
alias to \var{c_long}.
\end{classdesc}

\begin{classdesc}{c_int16}{\optional{value}}
Represents a C 16-bit \code{signed int} datatype.  Usually an alias
for \var{c_short}.
\end{classdesc}

\begin{classdesc}{c_int32}{\optional{value}}
Represents a C 32-bit \code{signed int} datatype.  Usually an alias
for \code{c_int}.
\end{classdesc}

\begin{classdesc}{c_int64}{\optional{value}}
Represents a C 64-bit \code{signed int} datatype.  Usually an alias
for \code{c_longlong}.
\end{classdesc}

\begin{classdesc}{c_int8}{\optional{value}}
Represents a C 8-bit \code{signed int} datatype.  Usually an alias for \code{c_byte}.
\end{classdesc}

\begin{classdesc}{c_long}{\optional{value}}
Represents a C \code{signed long} datatype.  The constructor accepts
an optional integer initializer; no overflow checking is done.
\end{classdesc}

\begin{classdesc}{c_longlong}{\optional{value}}
Represents a C \code{signed long long} datatype.  The constructor
accepts an optional integer initializer; no overflow checking is done.
\end{classdesc}

\begin{classdesc}{c_short}{\optional{value}}
Represents a C \code{signed short} datatype.  The constructor accepts
an optional integer initializer; no overflow checking is done.
\end{classdesc}

\begin{classdesc}{c_size_t}{\optional{value}}
Represents a C \code{size_t} datatype.
\end{classdesc}

\begin{classdesc}{c_ubyte}{\optional{value}}
\end{classdesc}

\begin{classdesc}{c_uint}{\optional{value}}
\end{classdesc}

\begin{classdesc}{c_uint16}{\optional{value}}
\end{classdesc}

\begin{classdesc}{c_uint32}{\optional{value}}
\end{classdesc}

\begin{classdesc}{c_uint64}{\optional{value}}
\end{classdesc}

\begin{classdesc}{c_uint8}{\optional{value}}
\end{classdesc}

\begin{classdesc}{c_ulong}{\optional{value}}
\end{classdesc}

\begin{classdesc}{c_ulonglong}{\optional{value}}
\end{classdesc}

\begin{classdesc}{c_ushort}{\optional{value}}
\end{classdesc}

\begin{classdesc}{c_void_p}{\optional{value}}
\end{classdesc}

\begin{classdesc}{c_wchar}{\optional{value}}
\end{classdesc}

\begin{classdesc}{c_wchar_p}{\optional{value}}
\end{classdesc}

% structured data types
\subsubsection{structured data types}

\begin{classdesc}{BigEndianStructure}{}
\end{classdesc}

\begin{classdesc}{LittleEndianStructure}{}
\end{classdesc}

\begin{classdesc}{Structure}{}
\end{classdesc}

\begin{classdesc}{Union}{}
\end{classdesc}



\begin{classdesc}{CDLL}{name, mode=RTLD_LOCAL, handle=None}
\end{classdesc}

\begin{datadesc}{cdll}
\end{datadesc}

\begin{classdesc}{HRESULT}{}
\end{classdesc}

\begin{classdesc}{LibraryLoader}{dlltype}
\end{classdesc}

\begin{classdesc}{OleDLL}{name, mode=RTLD_LOCAL, handle=None}
\end{classdesc}

\begin{datadesc}{oledll}
\end{datadesc}

\begin{classdesc}{py_object}{}
\end{classdesc}

\begin{classdesc}{PyDLL}{name, mode=RTLD_LOCAL, handle=None}
\end{classdesc}

\begin{datadesc}{pydll}{}
\end{datadesc}

\begin{datadesc}{RTLD_GLOBAL}
\end{datadesc}

\begin{datadesc}{RTLD_LOCAL}
\end{datadesc}

\begin{classdesc}{WinDLL}{name, mode=RTLD_LOCAL, handle=None}
\end{classdesc}

\begin{datadesc}{windll}
\end{datadesc}

