% Contributed by Skip Montanaro, from the module's doc strings.

\section{Built-in Module \sectcode{operator}}	% If implemented in C
\bimodindex{operator}

The \code{operator} module exports a set of functions implemented in C
corresponding to the intrinsic operators of Python.  For example,
{}\code{operator.add(x, y)} is equivalent to the expression x+y.  The
function names are those used for special class methods; variants without
leading and trailing \samp{__} are also provided for convenience.

The \code{operator} module defines the following functions:

\renewcommand{\indexsubitem}{(in module operator)}

\begin{funcdesc}{add}{a, b}
Return a + b, for a and b numbers.
\end{funcdesc}

\begin{funcdesc}{__add__}{a, b}
Return a + b, for a and b numbers.
\end{funcdesc}

\begin{funcdesc}{sub}{a, b}
Return a - b.
\end{funcdesc}

\begin{funcdesc}{__sub__}{a, b}
Return a - b.
\end{funcdesc}

\begin{funcdesc}{mul}{a, b}
Return a * b, for a and b numbers.
\end{funcdesc}

\begin{funcdesc}{__mul__}{a, b}
Return a * b, for a and b numbers.
\end{funcdesc}

\begin{funcdesc}{div}{a, b}
Return a / b.
\end{funcdesc}

\begin{funcdesc}{__div__}{a, b}
Return a / b.
\end{funcdesc}

\begin{funcdesc}{mod}{a, b}
Return a \% b.
\end{funcdesc}

\begin{funcdesc}{__mod__}{a, b}
Return a \% b.
\end{funcdesc}

\begin{funcdesc}{neg}{o}
Return o negated.
\end{funcdesc}

\begin{funcdesc}{__neg__}{o}
Return o negated.
\end{funcdesc}

\begin{funcdesc}{pos}{o}
Return o positive.
\end{funcdesc}

\begin{funcdesc}{__pos__}{o}
Return o positive.
\end{funcdesc}

\begin{funcdesc}{abs}{o}
Return the absolute value of o.
\end{funcdesc}

\begin{funcdesc}{__abs__}{o}
Return the absolute value of o.
\end{funcdesc}

\begin{funcdesc}{inv}{o}
Return the inverse of o.
\end{funcdesc}

\begin{funcdesc}{__inv__}{o}
Return the inverse of o.
\end{funcdesc}

\begin{funcdesc}{lshift}{a, b}
Return a shifted left by b.
\end{funcdesc}

\begin{funcdesc}{__lshift__}{a, b}
Return a shifted left by b.
\end{funcdesc}

\begin{funcdesc}{rshift}{a, b}
Return a shifted right by b.
\end{funcdesc}

\begin{funcdesc}{__rshift__}{a, b}
Return a shifted right by b.
\end{funcdesc}

\begin{funcdesc}{and_}{a, b}
Return the bitwise and of a and b.
\end{funcdesc}

\begin{funcdesc}{__and__}{a, b}
Return the bitwise and of a and b.
\end{funcdesc}

\begin{funcdesc}{or_}{a, b}
Return the bitwise or of a and b.
\end{funcdesc}

\begin{funcdesc}{__or__}{a, b}
Return the bitwise or of a and b.
\end{funcdesc}

\begin{funcdesc}{concat}{a, b}
Return a + b for a and b sequences.
\end{funcdesc}

\begin{funcdesc}{__concat__}{a, b}
Return a + b for a and b sequences.
\end{funcdesc}

\begin{funcdesc}{repeat}{a, b}
Return a * b where a is a sequence and b is an integer.
\end{funcdesc}

\begin{funcdesc}{__repeat__}{a, b}
Return a * b where a is a sequence and b is an integer.
\end{funcdesc}

\begin{funcdesc}{getitem}{a, b}
Return the value of a at index b.
\end{funcdesc}

\begin{funcdesc}{__getitem__}{a, b}
Return the value of a at index b.
\end{funcdesc}

\begin{funcdesc}{setitem}{a, b, c}
Set the value of a at index b to c.
\end{funcdesc}

\begin{funcdesc}{__setitem__}{a, b, c}
Set the value of a at index b to c.
\end{funcdesc}

\begin{funcdesc}{delitem}{a, b}
Set the value of a at index b.
\end{funcdesc}

\begin{funcdesc}{__delitem__}{a, b}
Set the value of a at index b.
\end{funcdesc}

\begin{funcdesc}{getslice}{a, b, c}
Return the slice of a from index b to index c-1.
\end{funcdesc}

\begin{funcdesc}{__getslice__}{a, b, c}
Return the slice of a from index b to index c-1.
\end{funcdesc}

\begin{funcdesc}{setslice}{a, b, c, v}
Set the slice of a from index b to index c-1 to the sequence v.
\end{funcdesc}

\begin{funcdesc}{__setslice__}{a, b, c, v}
Set the slice of a from index b to index c-1 to the sequence v.
\end{funcdesc}

\begin{funcdesc}{delslice}{a, b, c}
Delete the slice of a from index b to index c-1.
\end{funcdesc}

\begin{funcdesc}{__delslice__}{a, b, c}
Delete the slice of a from index b to index c-1.
\end{funcdesc}

Example: Build a dictionary that maps the ordinals from 0 to 256 to their
character equivalents.

\bcode\begin{verbatim}
>>> import operator
>>> d = {}
>>> keys = range(256)
>>> vals = map(chr, keys)
>>> map(operator.setitem, [d]*len(keys), keys, vals)
\end{verbatim}\ecode
