% LaTeXed from excellent doc-string.
\section{\module{codeop} ---
         Compile Python code}

\declaremodule{standard}{codeop}
\sectionauthor{Moshe Zadka}{mzadka@geocities.com}
\modulesynopsis{Compile (possibly incomplete) Python code.}

The \module{codeop} module provides a function to compile Python code
with hints on whether it certainly complete, possible complete or
definitely incomplete.  This is used by the \refmodule{code} module
and should not normally be used directly.

The \module{codeop} module defines the following function:

\begin{funcdesc}{compile_command}
                {source\optional{, filename\optional{, symbol}}}

Try to compile \var{source}, which should be a string of Python
code. Return a code object if \var{source} is valid
Python code. In that case, the filename attribute of the code object
will be \var{filename}, which defaults to \code{'<input>'}.

Return \code{None} if \var{source} is \emph{not} valid Python
code, but is a prefix of valid Python code.

Raise an exception if there is a problem with \var{source}:
\begin{itemize}
        \item \exception{SyntaxError}
              if there is invalid Python syntax.
        \item \exception{OverflowError}
              if there is an invalid numeric constant.
\end{itemize}

The \var{symbol} argument means whether to compile it as a statement
(\code{'single'}, the default) or as an expression (\code{'eval'}).

\strong{Caveat:}
It is possible (but not likely) that the parser stops parsing
with a successful outcome before reaching the end of the source;
in this case, trailing symbols may be ignored instead of causing an
error.  For example, a backslash followed by two newlines may be
followed by arbitrary garbage.  This will be fixed once the API
for the parser is better.
\end{funcdesc}
