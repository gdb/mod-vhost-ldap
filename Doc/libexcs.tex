\section{Built-in Exceptions}

Exceptions can be class objects or string objects.  While
traditionally, most exceptions have been string objects, in Python
1.5a4, all standard exceptions have been converted to class objects,
and users are encouraged to the the same.  The source code for those
exceptions is present in the standard library module
\code{exceptions}; this module never needs to be imported explicitly.

For backward compatibility, when Python is invoked with the \code{-X}
option, the standard exceptions are strings.  This may be needed to
run some code that breaks because of the different semantics of class
based exceptions.  The \code{-X} option will become obsolete in future
Python versions, so the recommended solution is to fix the code.

Two distinct string objects with the same value are considered different
exceptions.  This is done to force programmers to use exception names
rather than their string value when specifying exception handlers.
The string value of all built-in exceptions is their name, but this is
not a requirement for user-defined exceptions or exceptions defined by
library modules.

For class exceptions, in a \code{try} statement with an\code{except}
clause that mentions a particular class, that clause also handles
any exception classes derived from that class (but not exception
classes from which \emph{it} is derived).  Two exception classes
that are not related via subclassing are never equivalent, even if
they have the same name.
\stindex{try}
\stindex{except}

The built-in exceptions listed below can be generated by the
interpreter or built-in functions.  Except where mentioned, they have
an ``associated value'' indicating the detailed cause of the error.
This may be a string or a tuple containing several items of
information (e.g., an error code and a string explaining the code).
The associated value is the second argument to the \code{raise}
statement.  For string exceptions, the associated value itself will be
stored in the variable named as the second argument of the
\code{except} clause (if any).  For class exceptions derived from
the root class \code{Exception}, that variable receives the exception
instance, and the associated value is present as the exception
instance's \code{args} attribute; this is a tuple even if the second
argument to \code{raise} was not (then it is a singleton tuple).
\stindex{raise}

User code can raise built-in exceptions.  This can be used to test an
exception handler or to report an error condition ``just like'' the
situation in which the interpreter raises the same exception; but
beware that there is nothing to prevent user code from raising an
inappropriate error.

\renewcommand{\indexsubitem}{(built-in exception base class)}

The following exceptions are only used as base classes for other
exceptions.  When string-based standard exceptions are used, they
are tuples containing the directly derived classes.

\begin{excdesc}{Exception}
The root class for exceptions.  All built-in exceptions are derived
from this class.  All user-defined exceptions should also be derived
from this class, but this is not (yet) enforced.  The \code{str()}
function, when applied to an instance of this class (or most derived
classes) returns the string value of the argument or arguments, or an
empty string if no arguments were given to the constructor.  When used
as a sequence, this accesses the arguments given to the constructor
(handy for backward compatibility with old code).
\end{excdesc}

\begin{excdesc}{StandardError}
The base class for built-in exceptions.  All built-in exceptions are
derived from this class, which is itself derived from the root class
\code{Exception}.
\end{excdesc}

\begin{excdesc}{ArithmeticError}
The base class for those built-in exceptions that are raised for
various arithmetic errors: \code{OverflowError},
\code{ZeroDivisionError}, \code{FloatingPointError}.
\end{excdesc}

\begin{excdesc}{LookupError}
The base class for thise exceptions that are raised when a key or
index used on a mapping or sequence is invalid: \code{IndexError},
\code{KeyError}.
\end{excdesc}

\renewcommand{\indexsubitem}{(built-in exception base class)}

The following exceptions are the exceptions that are actually raised.
They are class objects, except when the \code{-X} option is used to
revert back to string-based standard exceptions.

\begin{excdesc}{AssertionError}
Raised when an \code{assert} statement fails.
\stindex{assert}
\end{excdesc}

\begin{excdesc}{AttributeError}
% xref to attribute reference?
  Raised when an attribute reference or assignment fails.  (When an
  object does not support attribute references or attribute assignments
  at all, \code{TypeError} is raised.)
\end{excdesc}

\begin{excdesc}{EOFError}
% XXXJH xrefs here
  Raised when one of the built-in functions (\code{input()} or
  \code{raw_input()}) hits an end-of-file condition (\EOF{}) without
  reading any data.
% XXXJH xrefs here
  (N.B.: the \code{read()} and \code{readline()} methods of file
  objects return an empty string when they hit \EOF{}.)  No associated value.
\end{excdesc}

\begin{excdesc}{FloatingPointError}
Raised when a floating point operation fails.  This exception is
always defined, but can only be raised when Python is configured with
the \code{--with-fpectl} option, or the \code{WANT_SIGFPE_HANDLER}
symbol is defined in the \file{config.h} file.
\end{excdesc}

\begin{excdesc}{IOError}
% XXXJH xrefs here
  Raised when an I/O operation (such as a \code{print} statement, the
  built-in \code{open()} function or a method of a file object) fails
  for an I/O-related reason, e.g., ``file not found'' or ``disk full''.

When class exceptions are used, and this exception is instantiated as
\code{IOError(errno, strerror)}, the instance has two additional
attributes \code{errno} and \code{strerror} set to the error code and
the error message, respectively.  These attributes default to
\code{None}.
\end{excdesc}

\begin{excdesc}{ImportError}
% XXXJH xref to import statement?
  Raised when an \code{import} statement fails to find the module
  definition or when a \code{from {\rm \ldots} import} fails to find a
  name that is to be imported.
\end{excdesc}

\begin{excdesc}{IndexError}
% XXXJH xref to sequences
  Raised when a sequence subscript is out of range.  (Slice indices are
  silently truncated to fall in the allowed range; if an index is not a
  plain integer, \code{TypeError} is raised.)
\end{excdesc}

\begin{excdesc}{KeyError}
% XXXJH xref to mapping objects?
  Raised when a mapping (dictionary) key is not found in the set of
  existing keys.
\end{excdesc}

\begin{excdesc}{KeyboardInterrupt}
  Raised when the user hits the interrupt key (normally
  \kbd{Control-C} or
\key{DEL}).  During execution, a check for interrupts is made regularly.
% XXXJH xrefs here
  Interrupts typed when a built-in function \code{input()} or
  \code{raw_input()}) is waiting for input also raise this exception.  No
  associated value.
\end{excdesc}

\begin{excdesc}{MemoryError}
  Raised when an operation runs out of memory but the situation may
  still be rescued (by deleting some objects).  The associated value is
  a string indicating what kind of (internal) operation ran out of memory.
  Note that because of the underlying memory management architecture
  (\C{}'s \code{malloc()} function), the interpreter may not always be able
  to completely recover from this situation; it nevertheless raises an
  exception so that a stack traceback can be printed, in case a run-away
  program was the cause.
\end{excdesc}

\begin{excdesc}{NameError}
  Raised when a local or global name is not found.  This applies only
  to unqualified names.  The associated value is the name that could
  not be found.
\end{excdesc}

\begin{excdesc}{OverflowError}
% XXXJH reference to long's and/or int's?
  Raised when the result of an arithmetic operation is too large to be
  represented.  This cannot occur for long integers (which would rather
  raise \code{MemoryError} than give up).  Because of the lack of
  standardization of floating point exception handling in \C{}, most
  floating point operations also aren't checked.  For plain integers,
  all operations that can overflow are checked except left shift, where
  typical applications prefer to drop bits than raise an exception.
\end{excdesc}

\begin{excdesc}{RuntimeError}
  Raised when an error is detected that doesn't fall in any of the
  other categories.  The associated value is a string indicating what
  precisely went wrong.  (This exception is mostly a relic from a
  previous version of the interpreter; it is not used very much any
  more.)
\end{excdesc}

\begin{excdesc}{SyntaxError}
% XXXJH xref to these functions?
  Raised when the parser encounters a syntax error.  This may occur in
  an \code{import} statement, in an \code{exec} statement, in a call
  to the built-in function \code{eval()} or \code{input()}, or
  when reading the initial script or standard input (also
  interactively).

When class exceptions are used, instances of this class have
atttributes \code{filename}, \code{lineno}, \code{offset} and
\code{text} for easier access to the details; for string exceptions,
the associated value is usually a tuple of the form
\code{(message, (filename, lineno, offset, text))}.
For class exceptions, \code{str()} returns only the message.
\end{excdesc}

\begin{excdesc}{SystemError}
  Raised when the interpreter finds an internal error, but the
  situation does not look so serious to cause it to abandon all hope.
  The associated value is a string indicating what went wrong (in
  low-level terms).
  
  You should report this to the author or maintainer of your Python
  interpreter.  Be sure to report the version string of the Python
  interpreter (\code{sys.version}; it is also printed at the start of an
  interactive Python session), the exact error message (the exception's
  associated value) and if possible the source of the program that
  triggered the error.
\end{excdesc}

\begin{excdesc}{SystemExit}
% XXXJH xref to module sys?
  This exception is raised by the \code{sys.exit()} function.  When it
  is not handled, the Python interpreter exits; no stack traceback is
  printed.  If the associated value is a plain integer, it specifies the
  system exit status (passed to \C{}'s \code{exit()} function); if it is
  \code{None}, the exit status is zero; if it has another type (such as
  a string), the object's value is printed and the exit status is one.

When class exceptions are used, the instance has an attribute
\code{code} which is set to the proposed exit status or error message
(defaulting to \code{None}).
  
  A call to \code{sys.exit} is translated into an exception so that
  clean-up handlers (\code{finally} clauses of \code{try} statements)
  can be executed, and so that a debugger can execute a script without
  running the risk of losing control.  The \code{os._exit()} function
  can be used if it is absolutely positively necessary to exit
  immediately (e.g., after a \code{fork()} in the child process).
\end{excdesc}

\begin{excdesc}{TypeError}
  Raised when a built-in operation or function is applied to an object
  of inappropriate type.  The associated value is a string giving
  details about the type mismatch.
\end{excdesc}

\begin{excdesc}{ValueError}
  Raised when a built-in operation or function receives an argument
  that has the right type but an inappropriate value, and the
  situation is not described by a more precise exception such as
  \code{IndexError}.
\end{excdesc}

\begin{excdesc}{ZeroDivisionError}
  Raised when the second argument of a division or modulo operation is
  zero.  The associated value is a string indicating the type of the
  operands and the operation.
\end{excdesc}
