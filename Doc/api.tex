\documentstyle[twoside,11pt,myformat]{report}

\title{Python-C API Reference}

\input{boilerplate}

\makeindex			% tell \index to actually write the .idx file


\begin{document}

\pagenumbering{roman}

\maketitle

\input{copyright}

\begin{abstract}

\noindent
This manual documents the API used by C (or C++) programmers who want
to write extension modules or embed Python.  It is a companion to
``Extending and Embedding the Python Interpreter'', which describes
the general principles of extension writing but does not document the
API functions in detail.

\end{abstract}

\pagebreak

{
\parskip = 0mm
\tableofcontents
}

\pagebreak

\pagenumbering{arabic}


\chapter{Introduction}

(XXX This is the old introduction, mostly by Jim Fulton -- should be
rewritten.)

From the viewpoint of of C access to Python services, we have:

\begin{enumerate}

\item "Very high level layer": two or three functions that let you
exec or eval arbitrary Python code given as a string in a module whose
name is given, passing C values in and getting C values out using
mkvalue/getargs style format strings.  This does not require the user
to declare any variables of type \code{PyObject *}.  This should be
enough to write a simple application that gets Python code from the
user, execs it, and returns the output or errors.

\item "Abstract objects layer": which is the subject of this chapter.
It has many functions operating on objects, and lest you do many
things from C that you can also write in Python, without going through
the Python parser.

\item "Concrete objects layer": This is the public type-dependent
interface provided by the standard built-in types, such as floats,
strings, and lists.  This interface exists and is currently documented
by the collection of include files provides with the Python
distributions.

\end{enumerate}

From the point of view of Python accessing services provided by C
modules:

\begin{enumerate}

\item[4.] "Python module interface": this interface consist of the basic
routines used to define modules and their members.  Most of the
current extensions-writing guide deals with this interface.

\item[5.] "Built-in object interface": this is the interface that a new
built-in type must provide and the mechanisms and rules that a
developer of a new built-in type must use and follow.

\end{enumerate}

The Python C API provides four groups of operations on objects,
corresponding to the same operations in the Python language: object,
numeric, sequence, and mapping.  Each protocol consists of a
collection of related operations.  If an operation that is not
provided by a particular type is invoked, then the standard exception
\code{TypeError} is raised with a operation name as an argument.

In addition, for convenience this interface defines a set of
constructors for building objects of built-in types.  This is needed
so new objects can be returned from C functions that otherwise treat
objects generically.

\section{Reference Counting}

For most of the functions in the Python-C API, if a function retains a
reference to a Python object passed as an argument, then the function
will increase the reference count of the object.  It is unnecessary
for the caller to increase the reference count of an argument in
anticipation of the object's retention.

Usually, Python objects returned from functions should be treated as
new objects.  Functions that return objects assume that the caller
will retain a reference and the reference count of the object has
already been incremented to account for this fact.  A caller that does
not retain a reference to an object that is returned from a function
must decrement the reference count of the object (using
\code{Py_DECREF()}) to prevent memory leaks.

Exceptions to these rules will be noted with the individual functions.

\section{Include Files}

All function, type and macro definitions needed to use the Python-C
API are included in your code by the following line:

\code{\#include "Python.h"}

This implies inclusion of the following standard header files:
stdio.h, string.h, errno.h, and stdlib.h (if available).

All user visible names defined by Python.h (except those defined by
the included standard headers) have one of the prefixes \code{Py} or
\code{_Py}.  Names beginning with \code{_Py} are for internal use
only.


\chapter{Initialization and Shutdown of an Embedded Python Interpreter}

When embedding the Python interpreter in a C or C++ program, the
interpreter must be initialized.

\begin{cfuncdesc}{void}{PyInitialize}{}
This function initializes the interpreter.  It must be called before
any interaction with the interpreter takes place.  If it is called
more than once, the second and further calls have no effect.

The function performs the following tasks: create an environment in
which modules can be imported and Python code can be executed;
initialize the \code{__builtin__} module; initialize the \code{sys}
module; initialize \code{sys.path}; initialize signal handling; and
create the empty \code{__main__} module.

In the current system, there is no way to undo all these
initializations or to create additional interpreter environments.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{Py_AtExit}{void (*func) ()}
Register a cleanup function to be called when Python exits.  The
cleanup function will be called with no arguments and should return no
value.  At most 32 cleanup functions can be registered.  When the
registration is successful, \code{Py_AtExit} returns 0; on failure, it
returns -1.  Each cleanup function will be called t most once.  The
cleanup function registered last is called first.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{Py_Exit}{int status}
Exit the current process.  This calls \code{Py_Cleanup()} (see next
item) and performs additional cleanup (under some circumstances it
will attempt to delete all modules), and then calls the standard C
library function \code{exit(status)}.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{Py_Cleanup}{}
Perform some of the cleanup that \code{Py_Exit} performs, but don't
exit the process.  In particular, this invokes the user's
\code{sys.exitfunc} function (if defined at all), and it invokes the
cleanup functions registered with \code{Py_AtExit()}, in reverse order
of their registration.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{Py_FatalError}{char *message}
Print a fatal error message and die.  No cleanup is performed.  This
function should only be invoked when a condition is detected that
would make it dangerous to continue using the Python interpreter;
e.g., when the object administration appears to be corrupted.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyImport_Init}{}
Initialize the module table.  For internal use only.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyImport_Cleanup}{}
Empty the module table.  For internal use only.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyBuiltin_Init}{}
Initialize the \code{__builtin__} module.  For internal use only.
\end{cfuncdesc}

XXX Other init functions: PyEval_InitThreads, PyOS_InitInterrupts,
PyMarshal_Init, PySys_Init.

\chapter{Reference Counting}

The functions in this chapter are used for managing reference counts
of Python objects.

\begin{cfuncdesc}{void}{Py_INCREF}{PyObject *o}
Increment the reference count for object \code{o}.  The object must
not be \NULL{}; if you aren't sure that it isn't \NULL{}, use
\code{Py_XINCREF()}.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{Py_XINCREF}{PyObject *o}
Increment the reference count for object \code{o}.  The object may be
\NULL{}, in which case the function has no effect.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{Py_DECREF}{PyObject *o}
Decrement the reference count for object \code{o}.  The object must
not be \NULL{}; if you aren't sure that it isn't \NULL{}, use
\code{Py_XDECREF()}.  If the reference count reaches zero, the object's
type's deallocation function (which must not be \NULL{}) is invoked.

\strong{Warning:} The deallocation function can cause arbitrary Python
code to be invoked (e.g. when a class instance with a \code{__del__()}
method is deallocated).  While exceptions in such code are not
propagated, the executed code has free access to all Python global
variables.  This means that any object that is reachable from a global
variable should be in a consistent state before \code{Py_DECREF()} is
invoked.  For example, code to delete an object from a list should
copy a reference to the deleted object in a temporary variable, update
the list data structure, and then call \code{Py_DECREF()} for the
temporary variable.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{Py_XDECREF}{PyObject *o}
Decrement the reference count for object \code{o}.The object may be
\NULL{}, in which case the function has no effect; otherwise the
effect is the same as for \code{Py_DECREF()}, and the same warning
applies.
\end{cfuncdesc}

The following functions are only for internal use:
\code{_Py_Dealloc}, \code{_Py_ForgetReference}, \code{_Py_NewReference},
as well as the global variable \code{_Py_RefTotal}.


\chapter{Exception Handling}

The functions in this chapter will let you handle and raise Python
exceptions.  It is important to understand some of the basics of
Python exception handling.  It works somewhat like the Unix
\code{errno} variable: there is a global indicator (per thread) of the
last error that occurred.  Most functions don't clear this on success,
but will set it to indicate the cause of the error on failure.  Most
functions also return an error indicator, usually \NULL{} if they are
supposed to return a pointer, or -1 if they return an integer
(exception: the \code{PyArg_Parse*()} functions return 1 for success and
0 for failure).  When a function must fail because of some function it
called failed, it generally doesn't set the error indicator; the
function it called already set it.

The error indicator consists of three Python objects corresponding to
the Python variables \code{sys.exc_type}, \code{sys.exc_value} and
\code{sys.exc_traceback}.  API functions exist to interact with the
error indicator in various ways.  There is a separate error indicator
for each thread.

% XXX Order of these should be more thoughtful.
% Either alphabetical or some kind of structure.

\begin{cfuncdesc}{void}{PyErr_Print}{}
Print a standard traceback to \code{sys.stderr} and clear the error
indicator.  Call this function only when the error indicator is set.
(Otherwise it will cause a fatal error!)
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyErr_Occurred}{}
Test whether the error indicator is set.  If set, return the exception
\code{type} (the first argument to the last call to one of the
\code{PyErr_Set*()} functions or to \code{PyErr_Restore()}).  If not
set, return \NULL{}.  You do not own a reference to the return value,
so you do not need to \code{Py_DECREF()} it.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_Clear}{}
Clear the error indicator.  If the error indicator is not set, there
is no effect.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_Fetch}{PyObject **ptype, PyObject **pvalue, PyObject **ptraceback}
Retrieve the error indicator into three variables whose addresses are
passed.  If the error indicator is not set, set all three variables to
\NULL{}.  If it is set, it will be cleared and you own a reference to
each object retrieved.  The value and traceback object may be \NULL{}
even when the type object is not.  \strong{Note:} this function is
normally only used by code that needs to handle exceptions or by code
that needs to save and restore the error indicator temporarily.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_Restore}{PyObject *type, PyObject *value, PyObject *traceback}
Set  the error indicator from the three objects.  If the error
indicator is already set, it is cleared first.  If the objects are
\NULL{}, the error indicator is cleared.  Do not pass a \NULL{} type
and non-\NULL{} value or traceback.  The exception type should be a
string or class; if it is a class, the value should be an instance of
that class.  Do not pass an invalid exception type or value.
(Violating these rules will cause subtle problems later.)  This call
takes away a reference to each object, i.e. you must own a reference
to each object before the call and after the call you no longer own
these references.  (If you don't understand this, don't use this
function.  I warned you.)  \strong{Note:} this function is normally
only used by code that needs to save and restore the error indicator
temporarily.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_SetString}{PyObject *type, char *message}
This is the most common way to set the error indicator.  The first
argument specifies the exception type; it is normally one of the
standard exceptions, e.g. \code{PyExc_RuntimeError}.  You need not
increment its reference count.  The second argument is an error
message; it is converted to a string object.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_SetObject}{PyObject *type, PyObject *value}
This function is similar to \code{PyErr_SetString()} but lets you
specify an arbitrary Python object for the ``value'' of the exception.
You need not increment its reference count.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_SetNone}{PyObject *type}
This is a shorthand for \code{PyErr_SetString(\var{type}, Py_None}.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyErr_BadArgument}{}
This is a shorthand for \code{PyErr_SetString(PyExc_TypeError,
\var{message})}, where \var{message} indicates that a built-in operation
was invoked with an illegal argument.  It is mostly for internal use.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyErr_NoMemory}{}
This is a shorthand for \code{PyErr_SetNone(PyExc_MemoryError)}; it
returns \NULL{} so an object allocation function can write
\code{return PyErr_NoMemory();} when  it runs out of memory.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyErr_SetFromErrno}{PyObject *type}
This is a convenience function to raise an exception when a C library
function has returned an error and set the C variable \code{errno}.
It constructs a tuple object whose first item is the integer
\code{errno} value and whose second item is the corresponding error
message (gotten from \code{strerror()}), and then calls
\code{PyErr_SetObject(\var{type}, \var{object})}.  On \UNIX{}, when
the \code{errno} value is \code{EINTR}, indicating an interrupted
system call, this calls \code{PyErr_CheckSignals()}, and if that set
the error indicator, leaves it set to that.  The function always
returns \NULL{}, so a wrapper function around a system call can write 
\code{return PyErr_NoMemory();} when  the system call returns an error.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_BadInternalCall}{}
This is a shorthand for \code{PyErr_SetString(PyExc_TypeError,
\var{message})}, where \var{message} indicates that an internal
operation (e.g. a Python-C API function) was invoked with an illegal
argument.  It is mostly for internal use.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyErr_CheckSignals}{}
This function interacts with Python's signal handling.  It checks
whether a signal has been sent to the processes and if so, invokes the
corresponding signal handler.  If the \code{signal} module is
supported, this can invoke a signal handler written in Python.  In all
cases, the default effect for \code{SIGINT} is to raise the
\code{KeyboadInterrupt} exception.  If an exception is raised the
error indicator is set and the function returns 1; otherwise the
function returns 0.  The error indicator may or may not be cleared if
it was previously set.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyErr_SetInterrupt}{}
This function is obsolete (XXX or platform dependent?).  It simulates
the effect of a \code{SIGINT} signal arriving -- the next time
\code{PyErr_CheckSignals()} is called, \code{KeyboadInterrupt} will be
raised.
\end{cfuncdesc}

\section{Standard Exceptions}

All standard Python exceptions are available as global variables whose
names are \code{PyExc_} followed by the Python exception name.
These have the type \code{PyObject *}; they are all string objects.
For completion, here are all the variables:
\code{PyExc_AccessError},
\code{PyExc_AssertionError},
\code{PyExc_AttributeError},
\code{PyExc_EOFError},
\code{PyExc_FloatingPointError},
\code{PyExc_IOError},
\code{PyExc_ImportError},
\code{PyExc_IndexError},
\code{PyExc_KeyError},
\code{PyExc_KeyboardInterrupt},
\code{PyExc_MemoryError},
\code{PyExc_NameError},
\code{PyExc_OverflowError},
\code{PyExc_RuntimeError},
\code{PyExc_SyntaxError},
\code{PyExc_SystemError},
\code{PyExc_SystemExit},
\code{PyExc_TypeError},
\code{PyExc_ValueError},
\code{PyExc_ZeroDivisionError}.


\chapter{Utilities}

The functions in this chapter perform various utility tasks, such as
parsing function arguments and constructing Python values from C
values.

\begin{cfuncdesc}{int}{Py_FdIsInteractive}{FILE *fp, char *filename}
Return true (nonzero) if the standard I/O file \code{fp} with name
\code{filename} is deemed interactive.  This is the case for files for
which \code{isatty(fileno(fp))} is true.  If the global flag
\code{Py_InteractiveFlag} is true, this function also returns true if
the \code{name} pointer is \NULL{} or if the name is equal to one of
the strings \code{"<stdin>"} or \code{"???"}.
\end{cfuncdesc}

\begin{cfuncdesc}{long}{PyOS_GetLastModificationTime}{char *filename}
Return the time of last modification of the file \code{filename}.
The result is encoded in the same way as the timestamp returned by
the standard C library function \code{time()}.
\end{cfuncdesc}


\chapter{Debugging}

XXX Explain Py_DEBUG, Py_TRACE_REFS, Py_REF_DEBUG.


\chapter{The Very High Level Layer}

The functions in this chapter will let you execute Python source code
given in a file or a buffer, but they will not let you interact in a
more detailed way with the interpreter.

\begin{cfuncdesc}{int}{PyRun_AnyFile}{FILE *, char *}
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyRun_SimpleString}{char *}
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyRun_SimpleFile}{FILE *, char *}
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyRun_InteractiveOne}{FILE *, char *}
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyRun_InteractiveLoop}{FILE *, char *}
\end{cfuncdesc}

\begin{cfuncdesc}{struct _node *}{PyParser_SimpleParseString}{char *, int}
\end{cfuncdesc}

\begin{cfuncdesc}{struct _node *}{PyParser_SimpleParseFile}{FILE *, char *, int}
\end{cfuncdesc}

\begin{cfuncdesc}{}{PyObject *PyRun}{ROTO((char *, int, PyObject *, PyObject *}
\end{cfuncdesc}

\begin{cfuncdesc}{}{PyObject *PyRun}{ROTO((FILE *, char *, int, PyObject *, PyObject *}
\end{cfuncdesc}

\begin{cfuncdesc}{}{PyObject *Py}{ROTO((char *, char *, int}
\end{cfuncdesc}


\chapter{Abstract Objects Layer}

The functions in this chapter interact with Python objects regardless
of their type, or with wide classes of object types (e.g. all
numerical types, or all sequence types).  When used on object types
for which they do not apply, they will flag a Python exception.

\section{Object Protocol}

\begin{cfuncdesc}{int}{PyObject_Print}{PyObject *o, FILE *fp, int flags}
Print an object \code{o}, on file \code{fp}.  Returns -1 on error
The flags argument is used to enable certain printing
options. The only option currently supported is \code{Py_Print_RAW}. 
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyObject_HasAttrString}{PyObject *o, char *attr_name}
Returns 1 if o has the attribute attr_name, and 0 otherwise.
This is equivalent to the Python expression:
\code{hasattr(o,attr_name)}.
This function always succeeds.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyObject_GetAttrString}{PyObject *o, char *attr_name}
Retrieve an attributed named attr_name form object o.
Returns the attribute value on success, or \NULL{} on failure.
This is the equivalent of the Python expression: \code{o.attr_name}.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyObject_HasAttr}{PyObject *o, PyObject *attr_name}
Returns 1 if o has the attribute attr_name, and 0 otherwise.
This is equivalent to the Python expression:
\code{hasattr(o,attr_name)}. 
This function always succeeds.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyObject_GetAttr}{PyObject *o, PyObject *attr_name}
Retrieve an attributed named attr_name form object o.
Returns the attribute value on success, or \NULL{} on failure.
This is the equivalent of the Python expression: o.attr_name.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyObject_SetAttrString}{PyObject *o, char *attr_name, PyObject *v}
Set the value of the attribute named \code{attr_name}, for object \code{o},
to the value \code{v}. Returns -1 on failure.  This is
the equivalent of the Python statement: \code{o.attr_name=v}.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyObject_SetAttr}{PyObject *o, PyObject *attr_name, PyObject *v}
Set the value of the attribute named \code{attr_name}, for
object \code{o},
to the value \code{v}. Returns -1 on failure.  This is
the equivalent of the Python statement: \code{o.attr_name=v}.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyObject_DelAttrString}{PyObject *o, char *attr_name}
Delete attribute named \code{attr_name}, for object \code{o}. Returns -1 on
failure.  This is the equivalent of the Python
statement: \code{del o.attr_name}.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyObject_DelAttr}{PyObject *o, PyObject *attr_name}
Delete attribute named \code{attr_name}, for object \code{o}. Returns -1 on
failure.  This is the equivalent of the Python
statement: \code{del o.attr_name}.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyObject_Cmp}{PyObject *o1, PyObject *o2, int *result}
Compare the values of \code{o1} and \code{o2} using a routine provided by
\code{o1}, if one exists, otherwise with a routine provided by \code{o2}.
The result of the comparison is returned in \code{result}.  Returns
-1 on failure.  This is the equivalent of the Python
statement: \code{result=cmp(o1,o2)}.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyObject_Compare}{PyObject *o1, PyObject *o2}
Compare the values of \code{o1} and \code{o2} using a routine provided by
\code{o1}, if one exists, otherwise with a routine provided by \code{o2}.
Returns the result of the comparison on success.  On error,
the value returned is undefined. This is equivalent to the
Python expression: \code{cmp(o1,o2)}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyObject_Repr}{PyObject *o}
Compute the string representation of object, \code{o}.  Returns the
string representation on success, \NULL{} on failure.  This is
the equivalent of the Python expression: \code{repr(o)}.
Called by the \code{repr()} built-in function and by reverse quotes.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyObject_Str}{PyObject *o}
Compute the string representation of object, \code{o}.  Returns the
string representation on success, \NULL{} on failure.  This is
the equivalent of the Python expression: \code{str(o)}.
Called by the \code{str()} built-in function and by the \code{print}
statement.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyCallable_Check}{PyObject *o}
Determine if the object \code{o}, is callable.  Return 1 if the
object is callable and 0 otherwise.
This function always succeeds.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyObject_CallObject}{PyObject *callable_object, PyObject *args}
Call a callable Python object \code{callable_object}, with
arguments given by the tuple \code{args}.  If no arguments are
needed, then args may be \NULL{}.  Returns the result of the
call on success, or \NULL{} on failure.  This is the equivalent
of the Python expression: \code{apply(o, args)}.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyObject_CallFunction}{PyObject *callable_object, char *format, ...}
Call a callable Python object \code{callable_object}, with a
variable number of C arguments. The C arguments are described
using a mkvalue-style format string. The format may be \NULL{},
indicating that no arguments are provided.  Returns the
result of the call on success, or \NULL{} on failure.  This is
the equivalent of the Python expression: \code{apply(o,args)}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyObject_CallMethod}{PyObject *o, char *m, char *format, ...}
Call the method named \code{m} of object \code{o} with a variable number of
C arguments.  The C arguments are described by a mkvalue
format string.  The format may be \NULL{}, indicating that no
arguments are provided. Returns the result of the call on
success, or \NULL{} on failure.  This is the equivalent of the
Python expression: \code{o.method(args)}.
Note that Special method names, such as "\code{__add__}",
"\code{__getitem__}", and so on are not supported. The specific
abstract-object routines for these must be used.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyObject_Hash}{PyObject *o}
Compute and return the hash value of an object \code{o}.  On
failure, return -1.  This is the equivalent of the Python
expression: \code{hash(o)}.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyObject_IsTrue}{PyObject *o}
Returns 1 if the object \code{o} is considered to be true, and
0 otherwise. This is equivalent to the Python expression:
\code{not not o}.
This function always succeeds.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyObject_Type}{PyObject *o}
On success, returns a type object corresponding to the object
type of object \code{o}. On failure, returns \NULL{}.  This is
equivalent to the Python expression: \code{type(o)}.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyObject_Length}{PyObject *o}
Return the length of object \code{o}.  If the object \code{o} provides
both sequence and mapping protocols, the sequence length is
returned. On error, -1 is returned.  This is the equivalent
to the Python expression: \code{len(o)}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyObject_GetItem}{PyObject *o, PyObject *key}
Return element of \code{o} corresponding to the object \code{key} or \NULL{}
on failure. This is the equivalent of the Python expression:
\code{o[key]}.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyObject_SetItem}{PyObject *o, PyObject *key, PyObject *v}
Map the object \code{key} to the value \code{v}.
Returns -1 on failure.  This is the equivalent
of the Python statement: \code{o[key]=v}.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyObject_DelItem}{PyObject *o, PyObject *key, PyObject *v}
Delete the mapping for \code{key} from \code{*o}.  Returns -1
on failure.
This is the equivalent of the Python statement: del o[key].
\end{cfuncdesc}


\section{Number Protocol}

\begin{cfuncdesc}{int}{PyNumber_Check}{PyObject *o}
Returns 1 if the object \code{o} provides numeric protocols, and
false otherwise. 
This function always succeeds.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Add}{PyObject *o1, PyObject *o2}
Returns the result of adding \code{o1} and \code{o2}, or null on failure.
This is the equivalent of the Python expression: \code{o1+o2}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Subtract}{PyObject *o1, PyObject *o2}
Returns the result of subtracting \code{o2} from \code{o1}, or null on
failure.  This is the equivalent of the Python expression:
\code{o1-o2}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Multiply}{PyObject *o1, PyObject *o2}
Returns the result of multiplying \code{o1} and \code{o2}, or null on
failure.  This is the equivalent of the Python expression:
\code{o1*o2}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Divide}{PyObject *o1, PyObject *o2}
Returns the result of dividing \code{o1} by \code{o2}, or null on failure.
This is the equivalent of the Python expression: \code{o1/o2}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Remainder}{PyObject *o1, PyObject *o2}
Returns the remainder of dividing \code{o1} by \code{o2}, or null on
failure.  This is the equivalent of the Python expression:
\code{o1\%o2}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Divmod}{PyObject *o1, PyObject *o2}
See the built-in function divmod.  Returns \NULL{} on failure.
This is the equivalent of the Python expression:
\code{divmod(o1,o2)}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Power}{PyObject *o1, PyObject *o2, PyObject *o3}
See the built-in function pow.  Returns \NULL{} on failure.
This is the equivalent of the Python expression:
\code{pow(o1,o2,o3)}, where \code{o3} is optional.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Negative}{PyObject *o}
Returns the negation of \code{o} on success, or null on failure.
This is the equivalent of the Python expression: \code{-o}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Positive}{PyObject *o}
Returns \code{o} on success, or \NULL{} on failure.
This is the equivalent of the Python expression: \code{+o}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Absolute}{PyObject *o}
Returns the absolute value of \code{o}, or null on failure.  This is
the equivalent of the Python expression: \code{abs(o)}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Invert}{PyObject *o}
Returns the bitwise negation of \code{o} on success, or \NULL{} on
failure.  This is the equivalent of the Python expression:
\code{~o}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Lshift}{PyObject *o1, PyObject *o2}
Returns the result of left shifting \code{o1} by \code{o2} on success, or
\NULL{} on failure.  This is the equivalent of the Python
expression: \code{o1 << o2}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Rshift}{PyObject *o1, PyObject *o2}
Returns the result of right shifting \code{o1} by \code{o2} on success, or
\NULL{} on failure.  This is the equivalent of the Python
expression: \code{o1 >> o2}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_And}{PyObject *o1, PyObject *o2}
Returns the result of "anding" \code{o2} and \code{o2} on success and \NULL{}
on failure. This is the equivalent of the Python
expression: \code{o1 and o2}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Xor}{PyObject *o1, PyObject *o2}
Returns the bitwise exclusive or of \code{o1} by \code{o2} on success, or
\NULL{} on failure.  This is the equivalent of the Python
expression: \code{o1\^{ }o2}.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyNumber_Or}{PyObject *o1, PyObject *o2}
Returns the result or \code{o1} and \code{o2} on success, or \NULL{} on
failure.  This is the equivalent of the Python expression: 
\code{o1 or o2}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Coerce}{PyObject *o1, PyObject *o2}
This function takes the addresses of two variables of type
\code{PyObject*}.

If the objects pointed to by \code{*p1} and \code{*p2} have the same type,
increment their reference count and return 0 (success).
If the objects can be converted to a common numeric type,
replace \code{*p1} and \code{*p2} by their converted value (with 'new'
reference counts), and return 0.
If no conversion is possible, or if some other error occurs,
return -1 (failure) and don't increment the reference counts.
The call \code{PyNumber_Coerce(\&o1, \&o2)} is equivalent to the Python
statement \code{o1, o2 = coerce(o1, o2)}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Int}{PyObject *o}
Returns the \code{o} converted to an integer object on success, or
\NULL{} on failure.  This is the equivalent of the Python
expression: \code{int(o)}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Long}{PyObject *o}
Returns the \code{o} converted to a long integer object on success,
or \NULL{} on failure.  This is the equivalent of the Python
expression: \code{long(o)}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyNumber_Float}{PyObject *o}
Returns the \code{o} converted to a float object on success, or \NULL{}
on failure.  This is the equivalent of the Python expression:
\code{float(o)}.
\end{cfuncdesc}


\section{Sequence protocol}

\begin{cfuncdesc}{int}{PySequence_Check}{PyObject *o}
Return 1 if the object provides sequence protocol, and 0
otherwise.  
This function always succeeds.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PySequence_Concat}{PyObject *o1, PyObject *o2}
Return the concatination of \code{o1} and \code{o2} on success, and \NULL{} on
failure.   This is the equivalent of the Python
expression: \code{o1+o2}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PySequence_Repeat}{PyObject *o, int count}
Return the result of repeating sequence object \code{o} count times,
or \NULL{} on failure.  This is the equivalent of the Python
expression: \code{o*count}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PySequence_GetItem}{PyObject *o, int i}
Return the ith element of \code{o}, or \NULL{} on failure. This is the
equivalent of the Python expression: \code{o[i]}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PySequence_GetSlice}{PyObject *o, int i1, int i2}
Return the slice of sequence object \code{o} between \code{i1} and \code{i2}, or
\NULL{} on failure. This is the equivalent of the Python
expression, \code{o[i1:i2]}.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PySequence_SetItem}{PyObject *o, int i, PyObject *v}
Assign object \code{v} to the \code{i}th element of \code{o}.
Returns -1 on failure.  This is the equivalent of the Python
statement, \code{o[i]=v}.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PySequence_DelItem}{PyObject *o, int i}
Delete the \code{i}th element of object \code{v}.  Returns
-1 on failure.  This is the equivalent of the Python
statement: \code{del o[i]}.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PySequence_SetSlice}{PyObject *o, int i1, int i2, PyObject *v}
Assign the sequence object \code{v} to the slice in sequence
object \code{o} from \code{i1} to \code{i2}.  This is the equivalent of the Python
statement, \code{o[i1:i2]=v}.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PySequence_DelSlice}{PyObject *o, int i1, int i2}
Delete the slice in sequence object, \code{o}, from \code{i1} to \code{i2}.
Returns -1 on failure. This is the equivalent of the Python
statement: \code{del o[i1:i2]}.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PySequence_Tuple}{PyObject *o}
Returns the \code{o} as a tuple on success, and \NULL{} on failure.
This is equivalent to the Python expression: \code{tuple(o)}.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PySequence_Count}{PyObject *o, PyObject *value}
Return the number of occurrences of \code{value} on \code{o}, that is,
return the number of keys for which \code{o[key]==value}.  On
failure, return -1.  This is equivalent to the Python
expression: \code{o.count(value)}.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PySequence_In}{PyObject *o, PyObject *value}
Determine if \code{o} contains \code{value}.  If an item in \code{o} is equal to
\code{value}, return 1, otherwise return 0.  On error, return -1.  This
is equivalent to the Python expression: \code{value in o}.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PySequence_Index}{PyObject *o, PyObject *value}
Return the first index for which \code{o[i]=value}.  On error,
return -1.    This is equivalent to the Python
expression: \code{o.index(value)}.
\end{cfuncdesc}

\section{Mapping protocol}

\begin{cfuncdesc}{int}{PyMapping_Check}{PyObject *o}
Return 1 if the object provides mapping protocol, and 0
otherwise.  
This function always succeeds.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyMapping_Length}{PyObject *o}
Returns the number of keys in object \code{o} on success, and -1 on
failure.  For objects that do not provide sequence protocol,
this is equivalent to the Python expression: \code{len(o)}.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyMapping_DelItemString}{PyObject *o, char *key}
Remove the mapping for object \code{key} from the object \code{o}.
Return -1 on failure.  This is equivalent to
the Python statement: \code{del o[key]}.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyMapping_DelItem}{PyObject *o, PyObject *key}
Remove the mapping for object \code{key} from the object \code{o}.
Return -1 on failure.  This is equivalent to
the Python statement: \code{del o[key]}.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyMapping_HasKeyString}{PyObject *o, char *key}
On success, return 1 if the mapping object has the key \code{key}
and 0 otherwise.  This is equivalent to the Python expression:
\code{o.has_key(key)}. 
This function always succeeds.
\end{cfuncdesc}


\begin{cfuncdesc}{int}{PyMapping_HasKey}{PyObject *o, PyObject *key}
Return 1 if the mapping object has the key \code{key}
and 0 otherwise.  This is equivalent to the Python expression:
\code{o.has_key(key)}. 
This function always succeeds.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyMapping_Keys}{PyObject *o}
On success, return a list of the keys in object \code{o}.  On
failure, return \NULL{}. This is equivalent to the Python
expression: \code{o.keys()}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyMapping_Values}{PyObject *o}
On success, return a list of the values in object \code{o}.  On
failure, return \NULL{}. This is equivalent to the Python
expression: \code{o.values()}.
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyMapping_Items}{PyObject *o}
On success, return a list of the items in object \code{o}, where
each item is a tuple containing a key-value pair.  On
failure, return \NULL{}. This is equivalent to the Python
expression: \code{o.items()}.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyMapping_Clear}{PyObject *o}
Make object \code{o} empty.  Returns 1 on success and 0 on failure.
This is equivalent to the Python statement:
\code{for key in o.keys(): del o[key]}
\end{cfuncdesc}


\begin{cfuncdesc}{PyObject*}{PyMapping_GetItemString}{PyObject *o, char *key}
Return element of \code{o} corresponding to the object \code{key} or \NULL{}
on failure. This is the equivalent of the Python expression:
\code{o[key]}.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyMapping_SetItemString}{PyObject *o, char *key, PyObject *v}
Map the object \code{key} to the value \code{v} in object \code{o}.  Returns 
-1 on failure.  This is the equivalent of the Python
statement: \code{o[key]=v}.
\end{cfuncdesc}


\section{Constructors}

\begin{cfuncdesc}{PyObject*}{PyFile_FromString}{char *file_name, char *mode}
On success, returns a new file object that is opened on the
file given by \code{file_name}, with a file mode given by \code{mode},
where \code{mode} has the same semantics as the standard C routine,
fopen.  On failure, return -1.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyFile_FromFile}{FILE *fp, char *file_name, char *mode, int close_on_del}
Return a new file object for an already opened standard C
file pointer, \code{fp}.  A file name, \code{file_name}, and open mode,
\code{mode}, must be provided as well as a flag, \code{close_on_del}, that
indicates whether the file is to be closed when the file
object is destroyed.  On failure, return -1.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyFloat_FromDouble}{double v}
Returns a new float object with the value \code{v} on success, and
\NULL{} on failure.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyInt_FromLong}{long v}
Returns a new int object with the value \code{v} on success, and
\NULL{} on failure.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyList_New}{int l}
Returns a new list of length \code{l} on success, and \NULL{} on
failure.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyLong_FromLong}{long v}
Returns a new long object with the value \code{v} on success, and
\NULL{} on failure.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyLong_FromDouble}{double v}
Returns a new long object with the value \code{v} on success, and
\NULL{} on failure.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyDict_New}{}
Returns a new empty dictionary on success, and \NULL{} on
failure.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyString_FromString}{char *v}
Returns a new string object with the value \code{v} on success, and
\NULL{} on failure.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyString_FromStringAndSize}{char *v, int l}
Returns a new string object with the value \code{v} and length \code{l}
on success, and \NULL{} on failure.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject*}{PyTuple_New}{int l}
Returns a new tuple of length \code{l} on success, and \NULL{} on
failure.
\end{cfuncdesc}


\chapter{Concrete Objects Layer}

The functions in this chapter are specific to certain Python object
types.  Passing them an object of the wrong type is not a good idea;
if you receive an object from a Python program and you are not sure
that it has the right type, you must perform a type check first;
e.g. to check that an object is a dictionary, use
\code{PyDict_Check()}.


\chapter{Defining New Object Types}

\begin{cfuncdesc}{PyObject *}{_PyObject_New}{PyTypeObject *type}
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{_PyObject_NewVar}{PyTypeObject *type, int size}
\end{cfuncdesc}

\begin{cfuncdesc}{TYPE}{_PyObject_NEW}{TYPE, PyTypeObject *}
\end{cfuncdesc}

\begin{cfuncdesc}{TYPE}{_PyObject_NEW_VAR}{TYPE, PyTypeObject *, int size}
\end{cfuncdesc}

XXX To be done:

PyObject, PyVarObject

PyObject_HEAD, PyObject_HEAD_INIT, PyObject_VAR_HEAD

Typedefs:
unaryfunc, binaryfunc, ternaryfunc, inquiry, coercion, intargfunc,
intintargfunc, intobjargproc, intintobjargproc, objobjargproc,
getreadbufferproc, getwritebufferproc, getsegcountproc,
destructor, printfunc, getattrfunc, getattrofunc, setattrfunc,
setattrofunc, cmpfunc, reprfunc, hashfunc

PyNumberMethods

PySequenceMethods

PyMappingMethods

PyBufferProcs

PyTypeObject

DL_IMPORT

PyType_Type

Py*_Check

Py_None, _Py_NoneStruct

_PyObject_New, _PyObject_NewVar

PyObject_NEW, PyObject_NEW_VAR


\chapter{Specific Data Types}

This chapter describes the functions that deal with specific types of 
Python objects.  It is structured like the ``family tree'' of Python 
object types.


\section{Fundamental Objects}

This section describes Python type objects and the singleton object 
\code{None}.


\subsection{Type Objects}

\begin{ctypedesc}{PyTypeObject}

\end{ctypedesc}

\begin{cvardesc}{PyObject *}{PyType_Type}

\end{cvardesc}


\subsection{The None Object}

\begin{cvardesc}{PyObject *}{Py_None}
macro
\end{cvardesc}


\section{Sequence Objects}

Generic operations on sequence objects were discussed in the previous 
chapter; this section deals with the specific kinds of sequence 
objects that are intrinsuc to the Python language.


\subsection{String Objects}

\begin{ctypedesc}{PyStringObject}
This subtype of \code{PyObject} represents a Python string object.
\end{ctypedesc}

\begin{cvardesc}{PyTypeObject}{PyString_Type}
This instance of \code{PyTypeObject} represents the Python string type.
\end{cvardesc}

\begin{cfuncdesc}{int}{PyString_Check}{PyObject *o}

\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyString_FromStringAndSize}{const char *, int}

\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyString_FromString}{const char *}

\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyString_Size}{PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{char *}{PyString_AsString}{PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyString_Concat}{PyObject **, PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyString_ConcatAndDel}{PyObject **, PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{int}{_PyString_Resize}{PyObject **, int}

\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyString_Format}{PyObject *, PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyString_InternInPlace}{PyObject **}

\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyString_InternFromString}{const char *}

\end{cfuncdesc}

\begin{cfuncdesc}{char *}{PyString_AS_STRING}{PyStringObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyString_GET_SIZE}{PyStringObject *}

\end{cfuncdesc}


\subsection{Tuple Objects}

\begin{ctypedesc}{PyTupleObject}
This subtype of \code{PyObject} represents a Python tuple object.
\end{ctypedesc}

\begin{cvardesc}{PyTypeObject}{PyTuple_Type}
This instance of \code{PyTypeObject} represents the Python tuple type.
\end{cvardesc}

\begin{cfuncdesc}{int}{PyTuple_Check}{PyObject *p}
Return true if the argument is a tuple object.
\end{cfuncdesc}

\begin{cfuncdesc}{PyTupleObject *}{PyTuple_New}{int s}
Return a new tuple object of size \code{s}
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyTuple_Size}{PyTupleObject *p}
akes a pointer to a tuple object, and returns the size
of that tuple.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyTuple_GetItem}{PyTupleObject *p, int pos}
returns the object at position \code{pos} in the tuple pointed
to by \code{p}.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyTuple_GET_ITEM}{PyTupleObject *p, int pos}
does the same, but does no checking of it's
arguments.
\end{cfuncdesc}

\begin{cfuncdesc}{PyTupleObject *}{PyTuple_GetSlice}{PyTupleObject *p,
            int low,
            int high}
takes a slice of the tuple pointed to by \code{p} from
\code{low} to \code{high} and returns it as a new tuple.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyTuple_SetItem}{PyTupleObject *p,
            int pos,
            PyObject *o}
inserts a reference to object \code{o} at position \code{pos} of
the tuple pointed to by \code{p}. It returns 0 on success.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyTuple_SET_ITEM}{PyTupleObject *p,
            int pos,
            PyObject *o}

does the same, but does no error checking, and
should \emph{only} be used to fill in brand new tuples.
\end{cfuncdesc}

\begin{cfuncdesc}{PyTupleObject *}{_PyTuple_Resize}{PyTupleObject *p,
            int new,
            int last_is_sticky}
can be used to resize a tuple. Because tuples are
\emph{supposed} to be immutable, this should only be used if there is only
one module referencing the object. Do \emph{not} use this if the tuple may
already be known to some other part of the code. \code{last_is_sticky} is
a flag - if set, the tuple will grow or shrink at the front, otherwise
it will grow or shrink at the end. Think of this as destroying the old
tuple and creating a new one, only more efficiently.
\end{cfuncdesc}


\subsection{List Objects}

\begin{ctypedesc}{PyListObject}
This subtype of \code{PyObject} represents a Python list object.
\end{ctypedesc}

\begin{cvardesc}{PyTypeObject}{PyList_Type}
This instance of \code{PyTypeObject} represents the Python list type.
\end{cvardesc}

\begin{cfuncdesc}{int}{PyList_Check}{PyObject *p}
returns true if it's argument is a \code{PyListObject}
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyList_New}{int size}

\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyList_Size}{PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyList_GetItem}{PyObject *, int}

\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyList_SetItem}{PyObject *, int, PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyList_Insert}{PyObject *, int, PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyList_Append}{PyObject *, PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyList_GetSlice}{PyObject *, int, int}

\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyList_SetSlice}{PyObject *, int, int, PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyList_Sort}{PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyList_Reverse}{PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyList_AsTuple}{PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyList_GET_ITEM}{PyObject *list, int i}

\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyList_GET_SIZE}{PyObject *list}

\end{cfuncdesc}


\section{Mapping Objects}

\subsection{Dictionary Objects}

\begin{ctypedesc}{PyDictObject}
This subtype of \code{PyObject} represents a Python dictionary object.
\end{ctypedesc}

\begin{cvardesc}{PyTypeObject}{PyDict_Type}
This instance of \code{PyTypeObject} represents the Python dictionary type.
\end{cvardesc}

\begin{cfuncdesc}{int}{PyDict_Check}{PyObject *p}
returns true if it's argument is a PyDictObject
\end{cfuncdesc}

\begin{cfuncdesc}{PyDictObject *}{PyDict_New}{}
returns a new empty dictionary.
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyDict_Clear}{PyDictObject *p}
empties an existing dictionary and deletes it.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyDict_SetItem}{PyDictObject *p,
            PyObject *key,
            PyObject *val}
inserts \code{value} into the dictionary with a key of
\code{key}. Both \code{key} and \code{value} should be PyObjects, and \code{key} should
be hashable.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyDict_SetItemString}{PyDictObject *p,
            char *key,
            PyObject *val}
inserts \code{value} into the dictionary using \code{key}
as a key. \code{key} should be a char *
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyDict_DelItem}{PyDictObject *p, PyObject *key}
removes the entry in dictionary \code{p} with key \code{key}.
\code{key} is a PyObject.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyDict_DelItemString}{PyDictObject *p, char *key}
removes the entry in dictionary \code{p} which has a key
specified by the \code{char *}\code{key}.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyDict_GetItem}{PyDictObject *p, PyObject *key}
returns the object from dictionary \code{p} which has a key
\code{key}.
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyDict_GetItemString}{PyDictObject *p, char *key}
does the same, but \code{key} is specified as a
\code{char *}, rather than a \code{PyObject *}.
\end{cfuncdesc}

\begin{cfuncdesc}{PyListObject *}{PyDict_Items}{PyDictObject *p}
returns a PyListObject containing all the items 
from the dictionary, as in the mapping method \code{items()} (see the Reference
Guide)
\end{cfuncdesc}

\begin{cfuncdesc}{PyListObject *}{PyDict_Keys}{PyDictObject *p}
returns a PyListObject containing all the keys 
from the dictionary, as in the mapping method \code{keys()} (see the Reference Guide)
\end{cfuncdesc}

\begin{cfuncdesc}{PyListObject *}{PyDict_Values}{PyDictObject *p}
returns a PyListObject containing all the values 
from the dictionary, as in the mapping method \code{values()} (see the Reference Guide)
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyDict_Size}{PyDictObject *p}
returns the number of items in the dictionary.
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyDict_Next}{PyDictObject *p,
            int ppos,
            PyObject **pkey,
            PyObject **pvalue}

\end{cfuncdesc}


\section{Numeric Objects}

\subsection{Plain Integer Objects}

\begin{ctypedesc}{PyIntObject}
This subtype of \code{PyObject} represents a Python integer object.
\end{ctypedesc}

\begin{cvardesc}{PyTypeObject}{PyInt_Type}
This instance of \code{PyTypeObject} represents the Python plain 
integer type.
\end{cvardesc}

\begin{cfuncdesc}{int}{PyInt_Check}{PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{PyIntObject *}{PyInt_FromLong}{long ival}
creates a new integer object with a value of \code{ival}.

The current implementation keeps an array of integer objects for all
integers between -1 and 100, when you create an int in that range you
actually just get back a reference to the existing object. So it should
be possible to change the value of 1. I suspect the behaviour of python
in this case is undefined. :-)
\end{cfuncdesc}

\begin{cfuncdesc}{long}{PyInt_AS_LONG}{PyIntObject *io}
returns the value of the object \code{io}.
\end{cfuncdesc}

\begin{cfuncdesc}{long}{PyInt_AsLong}{PyObject *io}
will first attempt to cast the object to a PyIntObject, if
it is not already one, and the return it's value.
\end{cfuncdesc}

\begin{cfuncdesc}{long}{PyInt_GetMax}{}
returns the systems idea of the largest int it can handle
(LONG_MAX, as defined in the system header files)
\end{cfuncdesc}


\subsection{Long Integer Objects}

\begin{ctypedesc}{PyLongObject}
This subtype of \code{PyObject} represents a Python long integer object.
\end{ctypedesc}

\begin{cvardesc}{PyTypeObject}{PyLong_Type}
This instance of \code{PyTypeObject} represents the Python long integer type.
\end{cvardesc}

\begin{cfuncdesc}{int}{PyLong_Check}{PyObject *p}
returns true if it's argument is a \code{PyLongObject}
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyLong_FromLong}{long}

\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyLong_FromUnsignedLong}{unsigned long}

\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyLong_FromDouble}{double}

\end{cfuncdesc}

\begin{cfuncdesc}{long}{PyLong_AsLong}{PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{unsigned long}{PyLong_AsUnsignedLong}{PyObject }

\end{cfuncdesc}

\begin{cfuncdesc}{double}{PyLong_AsDouble}{PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{*PyLong_FromString}{char *, char **, int}

\end{cfuncdesc}


\subsection{Floating Point Objects}

\begin{ctypedesc}{PyFloatObject}
This subtype of \code{PyObject} represents a Python floating point object.
\end{ctypedesc}

\begin{cvardesc}{PyTypeObject}{PyFloat_Type}
This instance of \code{PyTypeObject} represents the Python floating 
point type.
\end{cvardesc}

\begin{cfuncdesc}{int}{PyFloat_Check}{PyObject *p}
returns true if it's argument is a \code{PyFloatObject}
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyFloat_FromDouble}{double}

\end{cfuncdesc}

\begin{cfuncdesc}{double}{PyFloat_AsDouble}{PyObject *}

\end{cfuncdesc}

\begin{cfuncdesc}{double}{PyFloat_AS_DOUBLE}{PyFloatObject *}

\end{cfuncdesc}


\subsection{Complex Number Objects}

\begin{ctypedesc}{Py_complex}
typedef struct {
   double real;
   double imag;
} 
\end{ctypedesc}

\begin{ctypedesc}{PyComplexObject}
This subtype of \code{PyObject} represents a Python complex number object.
\end{ctypedesc}

\begin{cvardesc}{PyTypeObject}{PyComplex_Type}
This instance of \code{PyTypeObject} represents the Python complex 
number type.
\end{cvardesc}

\begin{cfuncdesc}{int}{PyComplex_Check}{PyObject *p}
returns true if it's argument is a \code{PyComplexObject}
\end{cfuncdesc}

\begin{cfuncdesc}{Py_complex}{_Py_c_sum}{Py_complex, Py_complex}

\end{cfuncdesc}

\begin{cfuncdesc}{Py_complex}{_Py_c_diff}{Py_complex, Py_complex}

\end{cfuncdesc}

\begin{cfuncdesc}{Py_complex}{_Py_c_neg}{Py_complex}

\end{cfuncdesc}

\begin{cfuncdesc}{Py_complex}{_Py_c_prod}{Py_complex, Py_complex}

\end{cfuncdesc}

\begin{cfuncdesc}{Py_complex}{_Py_c_quot}{Py_complex, Py_complex}

\end{cfuncdesc}

\begin{cfuncdesc}{Py_complex}{_Py_c_pow}{Py_complex, Py_complex}

\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyComplex_FromCComplex}{Py_complex}

\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyComplex_FromDoubles}{double real, double imag}

\end{cfuncdesc}

\begin{cfuncdesc}{double}{PyComplex_RealAsDouble}{PyObject *op}

\end{cfuncdesc}

\begin{cfuncdesc}{double}{PyComplex_ImagAsDouble}{PyObject *op}

\end{cfuncdesc}

\begin{cfuncdesc}{Py_complex}{PyComplex_AsCComplex}{PyObject *op}

\end{cfuncdesc}



\section{Other Objects}

\subsection{File Objects}

\begin{ctypedesc}{PyFileObject}
This subtype of \code{PyObject} represents a Python file object.
\end{ctypedesc}

\begin{cvardesc}{PyTypeObject}{PyFile_Type}
This instance of \code{PyTypeObject} represents the Python file type.
\end{cvardesc}

\begin{cfuncdesc}{int}{PyFile_Check}{PyObject *p}
returns true if it's argument is a \code{PyFileObject}
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyFile_FromString}{char *name, char *mode}
creates a new PyFileObject pointing to the file
specified in \code{name} with the mode specified in \code{mode}
\end{cfuncdesc}

\begin{cfuncdesc}{PyObject *}{PyFile_FromFile}{FILE *fp,
              char *name, char *mode, int (*close})
creates a new PyFileObject from the already-open \code{fp}.
The function \code{close} will be called when the file should be closed.
\end{cfuncdesc}

\begin{cfuncdesc}{FILE *}{PyFile_AsFile}{PyFileObject *p}
returns the file object associated with \code{p} as a \code{FILE *}
\end{cfuncdesc}

\begin{cfuncdesc}{PyStringObject *}{PyFile_GetLine}{PyObject *p, int n}
undocumented as yet
\end{cfuncdesc}

\begin{cfuncdesc}{PyStringObject *}{PyFile_Name}{PyObject *p}
returns the name of the file specified by \code{p} as a 
PyStringObject
\end{cfuncdesc}

\begin{cfuncdesc}{void}{PyFile_SetBufSize}{PyFileObject *p, int n}
on systems with \code{setvbuf} only
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyFile_SoftSpace}{PyFileObject *p, int newflag}
same as the file object method \code{softspace}
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyFile_WriteObject}{PyObject *obj, PyFileObject *p}
writes object \code{obj} to file object \code{p}
\end{cfuncdesc}

\begin{cfuncdesc}{int}{PyFile_WriteString}{char *s, PyFileObject *p}
writes string \code{s} to file object \code{p}
\end{cfuncdesc}


\input{api.ind}			% Index -- must be last

\end{document}
