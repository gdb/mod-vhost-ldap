#!/bin/ksh

#################################
#   AIX shared library helper	#
#################################

#   ========================================================================
#   FILENAME:       make_aix_so
#   MODULE FOR:     standalone executable
#   PLATFORM:       AIX (specific)
#   DESCRIPTION:    Creates a shareable .o from a pre-compiled (unshared)
#                   .o file
#   ARGUMENTS:      Same as for "ld".  The -bM, -bE, -bI, -H, -T, and -lc
#                   arguments of "ld" will be supplied by this script.
#   NOTES:          1.  Currently specific to the building of Python
#                       interpreter shared objects, in that the entry
#                       point name is hardcoded based on the object file
#                       name (the "mathmodule.o" file will expect an
#                       entry point of "initmath").  This could be remedied
#                       by the support (or simple expectation) of a "-e"
#                       argument.
#                   2.  The resulting shared object file is left in the
#                       current directory with the extension .so.  It may
#                       need to be changed to have a .o extension before
#                       it is usable.  (At least, Python expects it to
#                       have the .o extension, but this is simply because
#                       python wants it that way -- it COULD probably be
#                       called anything at all).
#   HISTORY:        Manus Hand (mhand@csn.net) -- Initial code -- 6/24/96
#   ========================================================================

#   ========================================================================
#                     SET UP VARIABLES FOR USE IN THIS SCRIPT
#   ------------------------------------------------------------------------
#   Note that the setting of "entry" is Python-build specific.  This script
#   is not general-purpose for that reason (although support for a "-e"
#   argument to it could be added, making it usable for any AIX application)
#   ========================================================================
objfile=$1
shift
filename=`echo $objfile | sed -e "s:.*/\([^/]*\)$:\1:" -e "s/\..*$//"`
entry=init`echo $filename | sed "s/module.*//"`
ldargs="-e$entry -bE:$filename.exp -bM:SRE -T512 -H512 -lc $objfile $*"
tmpfile=.py_$$

#   ======================================================================
#                             EXPORT LIST GENERATION
#   ----------------------------------------------------------------------
#   For the Python modules, this COULD be much simpler, since we know the
#   only exported variable is ".$entry" ("entry" was assigned just above).
#   However, the approach used here for export file generation is more
#   generic and will support all .o's, not just properly formatted Python-
#   importable modules.  Here is the rule:  any "extern" symbol name which
#   appears in the #   output of "nm" which IS resolved (i.e., which does
#   NOT have an address of zero) should go into the export list.  Read
#   each line from a temp file containing these symbols.  If it begins
#   with a dot, then add it to the list being built.  If it does not, then
#   see if the same symbol, with the dot prepended, also appears in the
#   list.  If so, DON'T include the current symbol (the one without the
#   prepended dot).
#   ======================================================================
exec 3>&1 1>$filename.exp
echo "#!$objfile"
nm $objfile | grep "|extern|" | grep -v " 0|extern|" | cut -f1 -d"|" > $tmpfile
while read line ; do
    echo "$line" | cut -c1 | read prefix
    if [ "$prefix" = "." ]; then
        echo "$line"
    else
        grep "^\.$line" $tmpfile > /dev/null
        if [ $? != 0 ]; then
            echo "$line" ; fi ; fi ; done < $tmpfile
rm $tmpfile

#   ===============================================================
#              IMPORT LIST AND SHARED OBJECT FILE GENERATION
#   ---------------------------------------------------------------
#   Send all output to the to-be-built import file, starting it off
#   with the required "#!" line (which tells it in which loaded
#   binary these symbols are to be found at runtime).  Then attempt
#   to ld the object using only the export list built above, and
#   hide the stderr output from "ld".  If the ld fails with status
#   code 8 (and in the case of the Python modules, it always does,
#   since each need some symbols from the statically linked portion
#   of the interpreter), this is because an import list should be
#   given containing the symbols which are unresolved.  The symbols
#   will have been sent to stdout as a side-effect of the failed ld
#   command, so by redirecting the stdout output, they will have
#   magically been put into the import file being built.  Then we
#   simply call ld again with both the import and export lists.
#   ===============================================================
exec 1>$filename.imp
echo "#!python"
ld $ldargs 2>/dev/null
status=$?
exec 1>&3

#   ================================================================
#   GUIDO:  If you want to separate the generation of the import and
#   export lists from the creation of the .so file, here's where the
#   break should be made -- in my mail I mentioned that some of this
#   script belongs in the pre-static link stage of the make and some
#   belongs after it.  As I said, here is the dividing line.   Now,
#   of course, if there is a module which needs NO statically linked
#   symbols -- but then again, there can't be, because they all need
#   initmodule4() -- the "ld" which is ABOVE this line may actually
#   have succeeded, so the "if" below will fail, but of course,
#   if you separate the script at this point, you won't care about
#   such things.
#   ================================================================
if [ $status = 8 ] ; then
    ld $ldargs $filename.imp ; fi

#   ======================================================================
#   GUIDO:  Remember that at this point, the files (assuming you leave the
#   arguments to LDSHARED totally unchanged) are still named with a .so
#   extension.  However, Python looks for them with a .o extension.  You
#   can either change this in the core code (#ifdef _AIX) so that it looks
#   for an .so or you can do what I did, which is rename them to .o's when
#   they get mv'ed by the sharedinstall make rule.  (Actually, I did it by
#   hand, but you'd do it in sharedinstall.
#   =======================================================================
