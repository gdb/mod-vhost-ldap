#ifndef Py_SYMTABLE_H
#define Py_SYMTABLE_H
#ifdef __cplusplus
extern "C" {
#endif

/* A symbol table is constructed each time PyNode_Compile() is
   called.  The table walks the entire parse tree and identifies each
   use or definition of a variable. 

   The symbol table contains a dictionary for each code block in a
   module: The symbol dictionary for the block.  They keys of these
   dictionaries are the name of all variables used or defined in the
   block; the integer values are used to store several flags,
   e.g. DEF_PARAM indicates that a variable is a parameter to a
   function. 

   The slots st_cur_XXX pointers always refer to the current code
   block.  The st_cur slot is the symbol dictionary.  The st_cur_id
   slot is the id is the key in st_symbols.  The st_cur_name slot is
   the name of the current scope. The st_cur_type slot is one of
   TYPE_FUNCTION, TYPE_CLASS, or TYPE_MODULE.  The st_cur_children is
   a list of the ids of the current node's children.

   The st_symbols slot is a dictionary that maps code block ids to
   symbol dictionaries.  The keys are generated by a counter that is
   incremented each time a new code block is found.  The counter is
   identifies a specific scope, because both passes walk the parse
   tree in the same order.

   The st_varnames slot is a dictionary that maps code block ids to
   parameter lists.  The st_global slot always refers to the symbol 
   dictionary for the module.

   The st_children slot is a dictionary that maps ids to a list
   containing the ids of its children.

   If st_keep is true then the namespace info pushed on st_stack will
   also be stored in st_scopes.  This is useful if the symbol table is
   being passed to something other than the compiler.
*/

struct symtable {
	int st_pass;             /* pass == 1 or 2 */
	int st_keep;             /* true if symtable will be returned */
	char *st_filename;       /* name of file being compiled */
	PyObject *st_symbols;    /* dictionary of symbol tables */
	PyObject *st_varnames;   /* dictionary of parameter lists */
        PyObject *st_stack;      /* stack of namespace info */
	PyObject *st_scopes;     /* dictionary of namespace info */
	PyObject *st_children;   /* dictionary (id=[ids]) */
	PyObject *st_cur;        /* borrowed ref to dict in st_symbols */
	PyObject *st_cur_name;   /* string, name of current scope */
	PyObject *st_cur_id;     /* int id of current code block */
	PyObject *st_cur_children; /* ref to current children list */
	int st_cur_type;         /* type of current scope */ 
	int st_cur_lineno;       /* line number where current scope begins */
	PyObject *st_global;     /* borrowed ref to MODULE in st_symbols */
	int st_nscopes;          /* number of scopes */
	int st_errors;           /* number of errors */
	char *st_private;        /* name of current class or NULL */
	int st_tmpname;          /* temporary name counter */
	int st_nested;           /* bool (true if nested scope) */
};

DL_IMPORT(struct symtable *) PyNode_CompileSymtable(struct _node *, char *);
DL_IMPORT(void) PySymtable_Free(struct symtable *);


#define TOP "global"
#define NOOPT ".noopt"

/* Flags for def-use information */

#define DEF_GLOBAL 1           /* global stmt */
#define DEF_LOCAL 2            /* assignment in code block */
#define DEF_PARAM 2<<1         /* formal parameter */
#define USE 2<<2               /* name is used */
#define DEF_STAR 2<<3          /* parameter is star arg */
#define DEF_DOUBLESTAR 2<<4    /* parameter is star-star arg */
#define DEF_INTUPLE 2<<5       /* name defined in tuple in parameters */
#define DEF_FREE 2<<6          /* name used by not defined in nested scope */
#define DEF_FREE_GLOBAL 2<<7   /* free variable is actually implicit global */
#define DEF_FREE_CLASS 2<<8    /* free variable from class's method */
#define DEF_IMPORT 2<<9        /* assignment occurred via import */

#define TYPE_FUNCTION 1
#define TYPE_CLASS 2
#define TYPE_MODULE 3

#define LOCAL 1
#define GLOBAL_EXPLICIT 2
#define GLOBAL_IMPLICIT 3
#define FREE 4
#define CELL 5

#ifdef __cplusplus
}
#endif
#endif /* !Py_SYMTABLE_H */
