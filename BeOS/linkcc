#! /bin/sh
#
# linkcc for Python
# Chris Herborth (chrish@qnx.com)
#
# This is covered by the same copyright/licensing terms as the rest of
# Python.
#
# Shell script to build the Python shared library properly; if we haven't
# already built the export list, we'll need to link twice (argh...) so we
# can eliminate some unwatnted global symbols from the system glue/init
# objects.
#
# This is called by the Modules/Makefile as part of $(LINKCC):
#
# $(LINKCC) $(LDFLAGS) $(LINKFORSHARED) $(MAINOBJ) \
#	-L.. -lpython$(VERSION) $(MODLIBS) $(LIBS) $(SYSLIBS) -o python $(LDLAST)
#
# In 1.5.1 this changed to:
#
# $(LINKCC) $(LDFLAGS) $(LINKFORSHARED) $(MAINOBJ) \
#	$(LIBRARY) $(MODLIBS) $(LIBS) $(SYSLIBS) -o python $(LDLAST)
#
# For BeOS we should set $(LINKCC) to this in configure (similar to the
# AIX situation):
#
# $(srcdir)../BeOS/linkcc $(LIBRARY) $(PURIFY) $(CC) -nodup $(OPT)
#
# -L.. -lpython$(VERSION) will automagically pick up the shared library.

# Check to make sure we know what we're doing.
system="`uname -m`"
if [ "$system" != "BeMac" ] && [ "$system" != "BeBox" ] ; then
	echo "Sorry, BeOS Python doesn't support x86 yet."
	exit 1
fi

LIBRARY="$1"; shift

# What we want to end up with.
EXPORTS=${LIBRARY%.a}.exp
DYNAMIC=${LIBRARY%.a}.so
LINK_DYNAMIC="-l`echo ${DYNAMIC%.so} | sed -e s,\\\.\\\./,, -e s,lib,,`"

# Grab the rest of the args and build them into the command used to
# link the python binary.  Make sure we link against the shared lib
# and not the static lib.
LINK_CMD=""
while [ "$#" != "0" ] ; do
	case "$1" in
		$LIBRARY)
			LINK_CMD="$LINK_CMD -L.. $LINK_DYNAMIC"
			shift
			;;
		*)
			LINK_CMD="$LINK_CMD $1"
			shift
			;;
	esac
done

# The shared libraries and glue objects we need to link against.
LIBS="-lbe -lnet -lroot"
GLUE="/boot/develop/lib/ppc/glue-noinit.a /boot/develop/lib/ppc/init_term_dyn.o"

# Unwanted symbols we need to eliminate; these are regular expressions
# passed to egrep.
SYMS="opterr optind optarg getopt __.* longjmp _.*_"

# Check to see if we've already got an exports file, and delete it if
# it's older than the lib.
if [ -e $EXPORTS ] && [ $LIBRARY -nt $EXPORTS ] ; then
	echo "Deleting old exports file for $DYNAMIC..."
	rm -f $EXPORTS
fi

if [ ! -e $EXPORTS ] ; then
	# First link; create the exports file with the unwanted global symbols
	# in it.  It's a pity we don't have "nm" or something like that...
	rm -f temp-exports.exp
	mwcc -xms -f temp-exports.exp -o $DYNAMIC $LIBRARY $GLUE $LIBS -nodup

	# Now clean out those bad symbols.
	for sym in $SYMS ; do 
		rm -f temp-exports.exp2
		egrep -v "^$sym$" < temp-exports.exp > temp-exports.exp2
		mv -f temp-exports.exp2 temp-exports.exp
	done

	rm -f temp-exports.exp2
	mv -f temp-exports.exp $EXPORTS
fi

# Now link against the clean exports file.
mwcc -xms -f $EXPORTS -o $DYNAMIC $LIBRARY $GLUE $LIBS -nodup

# We'll need this or the python binary won't load libpython.so...
( cd .. ; ln -sf `pwd` lib )

# Now build the python binary.
echo "Link command: $LINK_CMD"
$LINK_CMD
